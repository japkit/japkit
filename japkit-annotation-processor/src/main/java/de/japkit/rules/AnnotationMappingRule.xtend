package de.japkit.rules

import de.japkit.metaannotations.AnnotationMode
import de.japkit.metaannotations.DefaultAnnotation
import de.japkit.model.GenAnnotationMirror
import de.japkit.model.GenExtensions
import de.japkit.services.ExtensionRegistry
import de.japkit.services.GenerateClassContext
import de.japkit.services.ProcessingException
import java.util.List
import java.util.Map
import java.util.Set
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.type.DeclaredType
import org.eclipse.xtend.lib.annotations.Data

import static de.japkit.metaannotations.AnnotationMode.*
import de.japkit.services.TypeElementNotFoundException
import de.japkit.services.ReportedException
import de.japkit.annotations.AnnotationTemplate

@Data
class AnnotationMappingRule extends AbstractRule {
	val transient extension AnnotationExtensions = ExtensionRegistry.get(AnnotationExtensions)

	String id
	()=>boolean activationRule
	DeclaredType targetAnnotation
	AnnotationValueMappingRule[] valueMappings
	AnnotationMode mode

	Set<String> copyAnnotationsFqns
	String[] copyAnnotationsFromPackages
	boolean setShadowOnTriggerAnnotations
	((Object)=>Object)=>Iterable<Object> scopeRule

	/**
	 * Adds the annotation mapped by this rule.
	 * 
	 * @param annotations the annotations generated so far for the element
	 * @param srcElement the source element
	 */
	def void mapOrCopyAnnotations(List<GenAnnotationMirror> annotations) {
		inRule[
			try {
				if (!activationRule.apply) {
					return null
				}

				scopeRule.apply [
					copyAnnotations(annotations)

					if (!DefaultAnnotation.name.equals(targetAnnotation?.qualifiedName)) {
						mapAnnotation(annotations)
					}
					null // TODO. For now, we mutate the input list.
				]

			} catch (TypeElementNotFoundException tenfe) {
				//If there is a tenfe, no members are generated and the dependency to the unknown type is registered
				handleTypeElementNotFound(tenfe, currentAnnotatedClass)
				null
			} catch (ReportedException re){
				null
			} catch (RuntimeException re) {
				reportRuleError("Error during annotation mapping." + re)
				null
			}

		]

	}

	def private copyAnnotations(List<GenAnnotationMirror> annotations) {
		if (!copyAnnotationsFqns.empty || !copyAnnotationsFromPackages.empty) {
			currentSrcElement.annotationMirrors.filter[shallCopyAnnotation].forEach [
				try {
					annotations.add(copyAnnotation)
				} catch (ProcessingException e) {
					reportError(e)
				}
			]
		}
	}

	private def copyAnnotation(AnnotationMirror am) {
		val extension GenerateClassContext = ExtensionRegistry.get(GenerateClassContext)
		GenExtensions.copy(am) => [
			if (it.annotationType.qualifiedName == currentTriggerAnnotation.annotationType.qualifiedName) {
				putShadowAnnotation(it)
			}
			// TODO: Ist this still necessary here? 
			if (setShadowOnTriggerAnnotations) {
				setShadowIfAppropriate
			}
		]
	}

	def private boolean shallCopyAnnotation(AnnotationMirror am) {
		!ExtensionRegistry.get(GenExtensions).isJapkitAnnotation(am) && (
		copyAnnotationsFqns.contains(am.annotationType.qualifiedName) || {
			val packageFqn = am.annotationType.asElement.package.qualifiedName.toString
			copyAnnotationsFromPackages.exists [
				equals(packageFqn) || equals("*") || endsWith(".*") && packageFqn.equals(substring(0, it.length - 2)) ||
					endsWith(".**") && packageFqn.startsWith(substring(0, it.length - 3))
			]
		})
	}

	def private void mapAnnotation(List<GenAnnotationMirror> annotations) {

		var am = annotations.findFirst[hasFqn(targetAnnotation.qualifiedName)]

		if (am == null) {
			if (mode == REMOVE) {
				return
			} else {
				am = new GenAnnotationMirror(targetAnnotation)
				annotations.add(am)
			}
		} else {
			//TODO Neu machen. Funktioniert mit AnnotationTemplates nicht, da dort keine ids verwendet werden.
			if (id.nullOrEmpty) {
				switch (mode) {
					case ERROR_IF_EXISTS:
						throw new ProcessingException(
							'''The annotation «targetAnnotation.qualifiedName» was already generated by another rule and the mapping mode is «mode».''',
							if(currentSrc instanceof Element) currentSrcElement)
					case REPLACE: {
						annotations.remove(am)
						am = new GenAnnotationMirror(targetAnnotation)
						annotations.add(am)
					}
					case REMOVE: {
						annotations.remove(am);
						return
					}
					case MERGE: { /**Reuse existing one */
					}
					case IGNORE:
						return
					default:
						throw new ProcessingException('''Annotation mapping mode «mode» is not supported.''',
							if(currentSrc instanceof Element) currentSrcElement)
				}

			} else {
				// The AnnotationMapping is used from an annotation value mapping. Just ignore the mapping mode and create a new annotation.
				am = new GenAnnotationMirror(targetAnnotation)
				annotations.add(am)
			}

		}

		val anno = am

		valueStack.put("targetAnnotation", anno)

		anno => [
			valueMappings.forEach [ vm |
				try {
					setValue(vm.name, [ avType |
						vm.mapAnnotationValue(anno, avType)
					])

				} catch (RuntimeException e) {

					reportRuleError('''
					Could not set annotation value «vm.name» for mapped annotation «it?.annotationType?.qualifiedName».
					Cause: «e.message»''')
				}
			]
		]

	}

	new(AnnotationMirror am, Map<String, AnnotationMappingRule> annotationMappingsById) {
		super(am, null)
		id = am.value("id", String)
		activationRule = createActivationRule(am, null)
		targetAnnotation = am.value("targetAnnotation", DeclaredType)
		valueMappings = am.value("values", typeof(AnnotationMirror[])).map [
			new AnnotationValueMappingRule(it, annotationMappingsById)
		]
		mode = am.value("mode", AnnotationMode)
		
		scopeRule = createScopeRule(am, null, null)

		//TODO: Das sollte nicht Teil der AMR sein, denn diese bezieht sich immer auf genau einen Annotation-Typ
		copyAnnotationsFqns = am.value("copyAnnotations", typeof(DeclaredType[])).map[qualifiedName].toSet
		copyAnnotationsFromPackages = am.value("copyAnnotationsFromPackages", typeof(String[]))
		
		//TODO: Wann ist das relevant? nur für copyAnnotations?
		setShadowOnTriggerAnnotations = am.value("setShadowOnTriggerAnnotations", Boolean)		
	}
	
	new(AnnotationMirror annotationTemplate, Element templateElement){
		super(annotationTemplate, templateElement)
		id = null;
		setShadowOnTriggerAnnotations = false;
		activationRule = createActivationRule(annotationTemplate, "_")
		targetAnnotation = annotationTemplate.metaAnnotation(AnnotationTemplate).value("targetAnnotation", DeclaredType)

		valueMappings = targetAnnotation.asTypeElement.declaredMethods
			.map[simpleName]
			.map[name | new AnnotationValueMappingRule(annotationTemplate, templateElement, name.toString)]
		
		//TODO: Ziemlich sinnlos, da es scopeRule entgegensteht bei Collections.
		mode = AnnotationMode.ERROR_IF_EXISTS
		scopeRule = createScopeRule(annotationTemplate, null, "_")
		
		//TODO: Das sollte nicht Teil der AMR sein, denn diese bezieht sich immer auf genau einen Annotation-Typ
		copyAnnotationsFqns = emptySet
		copyAnnotationsFromPackages = emptyList
	}	
	

}
