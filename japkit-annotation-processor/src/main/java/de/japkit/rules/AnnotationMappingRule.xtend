package de.japkit.rules

import de.japkit.annotations.AnnotationTemplate
import de.japkit.metaannotations.AnnotationMode
import de.japkit.metaannotations.DefaultAnnotation
import de.japkit.model.GenAnnotationMirror
import de.japkit.model.GenExtensions
import de.japkit.services.ExtensionRegistry
import de.japkit.services.GenerateClassContext
import de.japkit.services.ReportedException
import de.japkit.rules.RuleException
import de.japkit.services.TypeElementNotFoundException
import java.util.List
import java.util.Map
import java.util.Set
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.type.DeclaredType
import org.eclipse.xtend.lib.annotations.Data

import static de.japkit.metaannotations.AnnotationMode.*

@Data
class AnnotationMappingRule extends AbstractRule {
	val transient extension AnnotationExtensions = ExtensionRegistry.get(AnnotationExtensions)

	String id
	()=>boolean activationRule
	DeclaredType targetAnnotation
	AnnotationValueMappingRule[] valueMappings
	AnnotationMode mode

	Set<String> copyAnnotationsFqns
	String[] copyAnnotationsFromPackages
	boolean setShadowOnTriggerAnnotations
	((Object)=>Object)=>Iterable<Object> scopeRule

	/**
	 * Adds the annotation mapped by this rule.
	 * 
	 * @param annotations the annotations generated so far for the element
	 * @param srcElement the source element
	 */
	def void mapOrCopyAnnotations(List<GenAnnotationMirror> annotations) {
		inRule[
			try {
				if (!activationRule.apply) {
					return null
				}

				scopeRule.apply [
					copyAnnotations(annotations)

					if (!DefaultAnnotation.name.equals(targetAnnotation?.qualifiedName)) {
						mapAnnotation(annotations)
					}
					null // TODO. For now, we mutate the input list.
				]

			} catch (TypeElementNotFoundException tenfe) {
				//If there is a tenfe, no members are generated and the dependency to the unknown type is registered
				handleTypeElementNotFound(tenfe, currentAnnotatedClass)
				null
			} catch (ReportedException re){
				null
			} catch (Exception re) {
				reportRuleError("Error during annotation mapping." + re)
				null
			}

		]

	}

	def private copyAnnotations(List<GenAnnotationMirror> annotations) {
		if (!copyAnnotationsFqns.empty || !copyAnnotationsFromPackages.empty) {
			currentSrcElement.annotationMirrors.filter[shallCopyAnnotation].forEach [
				annotations.add(copyAnnotation)
			]
		}
	}

	private def copyAnnotation(AnnotationMirror am) {
		val extension GenerateClassContext = ExtensionRegistry.get(GenerateClassContext)
		GenExtensions.copy(am) => [
			if (it.annotationType.qualifiedName == currentTriggerAnnotation.annotationType.qualifiedName) {
				putShadowAnnotation(it)
			}
			// TODO: Ist this still necessary here? 
			if (setShadowOnTriggerAnnotations) {
				setShadowIfAppropriate
			}
		]
	}

	def private boolean shallCopyAnnotation(AnnotationMirror am) {
		!ExtensionRegistry.get(GenExtensions).isJapkitAnnotation(am) && (
		copyAnnotationsFqns.contains(am.annotationType.qualifiedName) || {
			val packageFqn = am.annotationType.asElement.package.qualifiedName.toString
			copyAnnotationsFromPackages.exists [
				equals(packageFqn) || equals("*") || endsWith(".*") && packageFqn.equals(substring(0, it.length - 2)) ||
					endsWith(".**") && packageFqn.startsWith(substring(0, it.length - 3))
			]
		})
	}

	def private void mapAnnotation(List<GenAnnotationMirror> annotations) {

		var am = annotations.findFirst[hasFqn(targetAnnotation.qualifiedName)]

		if (am === null) {
			if (mode == REMOVE) {
				return
			} else {
				am = new GenAnnotationMirror(targetAnnotation)
				annotations.add(am)
			}
		} else {
			//TODO Neu machen. Funktioniert mit AnnotationTemplates nicht, da dort keine ids verwendet werden.
			if (id.nullOrEmpty) {
				switch (mode) {
					case ERROR_IF_EXISTS:
						throw new RuleException(
							'''The annotation «targetAnnotation.qualifiedName» was already generated by another rule and the mapping mode is «mode».''')
					case REPLACE: {
						annotations.remove(am)
						am = new GenAnnotationMirror(targetAnnotation)
						annotations.add(am)
					}
					case JOIN_LIST: {
						am = new GenAnnotationMirror(targetAnnotation)
						annotations.add(am)
					}
					case REMOVE: {
						annotations.remove(am);
						return
					}
					case MERGE: { /**Reuse existing one */
					}
					case IGNORE:
						return
					default:
						throw new RuleException('''Annotation mapping mode «mode» is not supported.''')
				}

			} else {
				// The AnnotationMapping is used from an annotation value mapping. Just ignore the mapping mode and create a new annotation.
				am = new GenAnnotationMirror(targetAnnotation)
				annotations.add(am)
			}

		}

		val anno = am

		valueStack.put("targetAnnotation", anno)

		anno => [
			valueMappings.forEach [ vm |
					setValue(vm.name, [ avType |
						vm.mapAnnotationValue(anno, avType)
					])
			]
		]

	}

	new(AnnotationMirror am, Map<String, AnnotationMappingRule> annotationMappingsById) {
		super(am, null)
		id = am.value("id", String)
		activationRule = createActivationRule(am, null)
		targetAnnotation = am.value("targetAnnotation", DeclaredType)
		valueMappings = am.value("values", typeof(AnnotationMirror[])).map [
			new AnnotationValueMappingRule(it, annotationMappingsById)
		]
		mode = am.value("mode", AnnotationMode)
		
		scopeRule = createScopeRule(am, null, null)

		//TODO: Das sollte nicht Teil der AMR sein, denn diese bezieht sich immer auf genau einen Annotation-Typ
		copyAnnotationsFqns = am.value("copyAnnotations", typeof(DeclaredType[])).map[qualifiedName].toSet
		copyAnnotationsFromPackages = am.value("copyAnnotationsFromPackages", typeof(String[]))
		
		//TODO: Wann ist das relevant? nur für copyAnnotations?
		setShadowOnTriggerAnnotations = am.value("setShadowOnTriggerAnnotations", Boolean)		
	}
	
	new(AnnotationMirror annotationTemplate, Element templateElement){
		super(annotationTemplate, templateElement)
		id = null;
		setShadowOnTriggerAnnotations = false;
		activationRule = createActivationRule(annotationTemplate, "_")
		targetAnnotation = annotationTemplate.metaAnnotation(AnnotationTemplate).value("targetAnnotation", DeclaredType)

		valueMappings = targetAnnotation.asTypeElement.declaredMethods
			.map[simpleName]
			.map[name | new AnnotationValueMappingRule(
				annotationTemplate,	templateElement, name.toString
			)]
		
		mode = AnnotationMode.JOIN_LIST
		scopeRule = createScopeRule(annotationTemplate, null, "_")
		
		//TODO: Das sollte nicht Teil der AMR sein, denn diese bezieht sich immer auf genau einen Annotation-Typ
		copyAnnotationsFqns = emptySet
		copyAnnotationsFromPackages = emptyList
	}	
	

}
