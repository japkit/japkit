package de.japkit.test.members;

import javax.lang.model.element.TypeElement;

import de.japkit.annotations.Order;
import de.japkit.annotations.RuntimeMetadata;
import de.japkit.metaannotations.Clazz;
import de.japkit.metaannotations.InnerClass;
import de.japkit.metaannotations.Template;
import de.japkit.metaannotations.TemplateCall;
import de.japkit.test.members.constructor.ConstructorTemplate;
import de.japkit.test.members.field.FieldTemplate;
import de.japkit.test.members.innerclass.InnerClassTemplate;
import de.japkit.test.members.method.MethodTemplate;

/**
 * Within Templates annotated with {@link Clazz}, {@link InnerClass} or
 * {@link Template}, fields, methods, constructors and inner classes can be
 * generated. {@link Clazz} represents a top level class, {@link InnerClass} is
 * an inner class within a top level class or another inner class.
 * {@link Template} is a reusable group of members.
 * <p>
 * Here, some basic examples are shown on how to generate members and how to use
 * {@link Template}.
 * <ul>
 * <li>For details on generating fields, see {@link FieldTemplate}.
 * <li>For details on generating methods, see {@link MethodTemplate}.
 * <li>For details on generating constructors, see {@link ConstructorTemplate}.
 * <li>For details on generating inner classes, see {@link InnerClassTemplate}.
 * </ul>
 */
@Clazz(commentExpr = "The generated class for the example.")
@RuntimeMetadata
public class MembersTemplate {

	/**
	 * A field within the generated top level class. It is generated by
	 * "copying" the field template.
	 */
	@Order(0)
	String fixedField;

	/**
	 * A constructor in the top level class.It is generated by "copying" the
	 * constructor template and adjusting the name.
	 */
	public MembersTemplate(String param1, int param2) {
	}

	/**
	 * A method within the generated top level class. It is generated by
	 * "copying" the method template.
	 */
	public void fixedMethod(String param) {
	};

	/**
	 * An inner class template. This will generate an inner class with the given
	 * name within the generated top level class.
	 */
	@InnerClass
	public class SomeInnerClass {
		/**
		 * A field within the generated inner class. It is generated by
		 * "copying" the field template.
		 */
		String fixedInnerClassField;

		/**
		 * A constructor in the inner class. It is generated by "copying" the
		 * constructor template and adjusting the name.
		 */
		public SomeInnerClass(String param1) {
		}

		/**
		 * A method within the generated inner class. It is generated by
		 * "copying" the method template.
		 */
		public void fixedInnerClassMethod(String param) {
		};

		/**
		 * Inner class templates can be nested.
		 */
		@InnerClass
		public class SomeInnerInnerClass {

		}
	}

	/**
	 * Members can be grouped together in {@link Template}s. For example, this
	 * is useful, if they share some common properties like the same src or
	 * condition.
	 * <p>
	 * Here, for a common src collection ('A', 'B'), a field and a method are
	 * generated. So, the resulting members in the generated top level class
	 * are: fieldA, methodA, fieldB, methodB.
	 * <p>
	 * Japkit does its best to enforce an order of generated elements. However,
	 * this has limitations, since in annotation processing, the order of
	 * elements in {@link TypeElement#getEnclosedElements()} is not as well
	 * defined as one might believe: Javac will (in opposite to JDT) return the
	 * element for the inner class FieldWithMethod BEFORE the element for the
	 * field fixedField. Thus, the generated field order would be fieldA,
	 * fieldB, fixedField instead of fixedField, fieldA, fieldB. To enforce the
	 * ordering, the {@link Order} annotation can be used. This is for example
	 * necessary to generate stable constructor signatures. In the example we
	 * need it for the unit test of the toString method.
	 * <p>
	 * If you the order annotation is used on one element, it should be used on
	 * all others that need ordering as well. Otherwise, their order will be
	 * undefined.
	 */
	@Order(1)
	@Template(src = "#{['A','B']}")
	public class FieldWithMethod {
		String field$src$;

		public void method$src$() {
		}
	}

	/**
	 * Templates can also be made reusable by putting them into separate
	 * classes. Here, the {@link ToStringTemplate} is applied to add a toString
	 * method to the generated class.
	 * <p>
	 * The type of the field is the template to be called. The name of the field
	 * is not relevant here.
	 */
	@TemplateCall
	ToStringTemplate generateToString;

}
